public class Hand {
   int[] cards;
   int bid;
   int patternType;
   int rank;

   int wildJackPattern;
   int[] wildJackCards;

   public Hand(int[] cards, int bid) {
       this.cards = cards;
       this.bid = bid;
       this.patternType = determinePattern(cards);
       this.rank = 0;


       this.wildJackCards = new int[5];
       this.wildJackPattern = -1;
   }


   private final HashMap<Integer, Integer> frequencies = new HashMap<>();


   /*
       The data a "Hand" object holds looks something like this


       An int array of the cards: [5, 5, 5, 5, Queen]
       The bid of the card: 684
       The Pattern Type: Four of a kind
       It's ranking (decided later).
    */


   public void printStats()
   {
       System.out.println("Cards: " + Arrays.toString(cards) + " \n Wild Switch: " + Arrays.toString(wildJackCards));
   }
   // Moved this logic from Main into the new Hand object. It is ran when a hand is initialized.
   private int determinePattern(int[] hand)
   {
       int[] freq = new int[15];
       for (int card : hand)
       {
           freq[card]++;
       }


       int doubles = 0;
       int triples = 0;
       int quadruples = 0;
       int fives = 0;




       for (int i = 2; i <= 14; i++)
       {
           switch (freq[i]) {
               case 2 -> doubles++;
               case 3 -> triples++;
               case 4 -> quadruples++;
               case 5 -> fives++;
           }
       }


       if (fives == 1)
       {
           return 7;
       }
       if (quadruples == 1)
       {
           return 6;
       }
       if (triples == 1 && doubles == 1)
       {
           return 5;
       }
       if (triples == 1)
       {
           return 4;
       }
       if (doubles == 2)
       {
           return 3;
       }
       if (doubles == 1)
       {
           return 2;
       }
       return 1; // high card






   }


   /*
       At this point, our hand object almost complete. What we want to do now is create a method to compare two different hands.
       Since we already have our patternType saved, we can easily do that to compare two hands with respective patterns like five of a kind vs four of a kind.


       However, we also have to deal with cases where the hands share a patternType.
       (i.e. hand 1 = five of a kind && hand 2 = five of a kind)
       According to the project doc, we can do this by comparing the numbers of each hands, which is fairly elementary to do.




       Note: The "rank" is really just how many other hands any given hand will beat, so we can just run the below for each hand against every other hand and add one to a variable each time
       it returns true.
    */




   // Hand 1 will be the one we are calling this method from, then the parameter will be the next hand.
   public boolean isStrongerThan(Hand other)
   {
       //Case 1: Different patternTypes
       if (this.patternType != other.patternType)
       {
           return this.patternType > other.patternType;
       }


       //Case 2: Tie-Breaker
       for (int i = 0; i < 5; i++)
       {
           if (this.cards[i] != other.cards[i])
           {
               return this.cards[i] > other.cards[i];
           }
       }


       // Unless we have two identical hands, this shouldn't happen
       return false;
   }


   // Note the above method returns a boolean, not an int.




   public void switchJacks() {
       for (int i = 0; i < cards.length; i++) 
       {
           if (cards[i] == 11)
           {
               wildJackCards[i] = 1;
           }
          else
           {
               wildJackCards[i] = cards[i];
           }
       }




       // Memory Inefficient but easier to manage
       ArrayList<Integer> cardsList = new ArrayList<>();
       for (int numbers : wildJackCards) 
       {
           cardsList.add(numbers);
       }


       for (int numbers : wildJackCards) 
           {
           if (numbers != 1) {
               frequencies.put(numbers, frequencies.getOrDefault(numbers, 0) + 1);


           }
       }




       // System.out.println("Cards before switch: " + Arrays.toString(cards));


       int mostCommonCard;


       if (frequencies.isEmpty()) {
           mostCommonCard = 14; // all Jacks â†’ five of a kind Aces
       }
       else
       {
           mostCommonCard = Collections.max(frequencies.entrySet(), Map.Entry.comparingByValue()).getKey();
       }



       for (int i = 0; i < cardsList.size(); i++) {
           if (cardsList.get(i) == 1)
           {
               if (mostCommonCard == 1)
               {
                   cardsList.set(i, 14);
               } else
               {
                   cardsList.set(i, mostCommonCard);
               }
           }
       }




       // Pass the new list of cards back through
           for (int j = 0; j <= 4; j++) {
               wildJackCards[j] = cardsList.get(j);
           }


           frequencies.clear();


           wildJackPattern = determinePattern(wildJackCards);


           // return wildJackCards;


           // System.out.println("map:" + frequencies);
           // System.out.println("most common card: " + mostCommonCard);
           // System.out.println("list" + cardsList);
           // System.out.println("cards after switch: " + Arrays.toString(cards));
       }




   public boolean isStrongerThanWildJacks(Hand other)
   {
       //Case 1: Different patternTypes
       if (this.wildJackPattern != other.wildJackPattern)
       {
           return this.wildJackPattern > other.wildJackPattern;
       }


       //Case 2: Tie-breaker:
       for (int i = 0; i < 5; i++)
       {
           int thisValue = this.cards[i];
           int otherValue = other.cards[i];


           if (thisValue == 11)
           {
               thisValue = 1;
           }
           if (otherValue == 11)
           {
               otherValue = 1;
           }


           if (thisValue != otherValue)
           {
               return thisValue > otherValue;
           }
       }


       return false;
   }


}
